# 实战项目: HTTP客户端和服务器端

我们将编写一个可以从web服务器下载文件的套接字程序!这将是我们的“网络客户端”。如果我们的代码正确的话，该客户端可以和任何web服务器通信。不仅如此，我们同样将编写一个简单的web服务器!这个程序将能够处理来自我们编写的web客户端的请求…或任何其他web客户端，如Chrome或Firefox!

这些程序都会使用一种你已经听说过的协议进行通信:HTTP，即超文本传输协议。正因为它们使用HTTP，而同样，像Chrome这样的浏览器也使用HTTP，所以它们之间可以通过该协议进行通信! 

## 限制

为了更好的从底层理解套接字API，该项目**不会**使用下面这些辅助函数:

* `socket.create_connection()` 函数
* `socket.create_server()` 函数
* 任何在`urllib`中的模块

当你完成这个项目时，你应该对于这些辅助函数如何工作的有了更深入的了解。 

## Python字符编码

Python套接字接收和发送的都是字节，不是Python中的字符串。当需要发送字符串或者想按照字符串模式打印字节时，用户需要将其进行转换。

字节序列取决于字符串所使用的 _字符编码_。字符编码决定了字节对应于哪一个编码，一些你可能听过的编码方式比如ASCII或者UTF-8，除此之外还有浩如烟海的编码方式。一般情况下，网页的默认编码为“ISO-8859-1”。

编码方式很重要，因为你必须把你的Python字符串编码成一个字节序列，而每当你这样做的时候，你需要指定编码方式。(默认为UTF-8。)

下面的示例表示如何把一个Python字符串转换为ISO-8859-1编码的序列:

``` {.py}
s = "Hello, world!"          # String
b = s.encode("ISO-8859-1")   # Sequence of bytes
```

这串编码序列将会通过套接字进行传输。下面的示例表示了如何将从套接字接收到的字节转换为ISO-8859-1字符串:

``` {.py}
s = b.decode("ISO-8859-1")
```

然后，你就可以将其按照人类可读的模式打印出来了。显然，如果数据并没有以ISO-8859-1进行编码，在字符串中，你会看到奇怪的字符或者之前得到一个错误。
编码ASCII、UTF-8和ISO-8859-1对于基础的拉丁字母，数字或者标点都是相同的，所以在这些编码下，所得到的字符串应该都是相同的，除非你开始处理一些奇怪的Unicode字符。

如果你是用C语言编程，大部分情况下你无需担心编码方式而只是直接打印出这些字节流。有时候你可能会得到一些垃圾值，不过在大多数情况下，都是可用的。

## HTTP 小结

HTTP是基于 _请求_ 和 _回复_ 的概念来进行操作的。客户端发起一个网页的请求，然后服务器端会将请求发回。

一个简单的HTTP请求如下:
``` {.default}
GET / HTTP/1.1
Host: example.com
Connection: close

```

上面展示了一个请求 _报头_ 长什么样，在第一行中包含了请求方法，路径以及协议，接着是任意的头部字段。在报头的最后，有一行空行。这个请求表示 “从服务器example.com获取根网页，我将在收到你的响应后立即关闭连接。”

请求头的每一行以回车/换行符(CRLF)结束，无论是Python还是C语言，都可以用以下方式表示CRLF:

``` {.py}
"\r\n"
```

如果你是在请求一个特定的文件，文件名会位于请求的第一行，看起来如下:

``` {.default}
GET /path/to/file.html HTTP/1.1
```

(如果这个报头中还有一个负载内容，它会被加在在空白行后面，同时带有一个 `Content-Length` 字段，并以字节为单位给出负载的长度。在这个项目中，我们并不会涉及这个内容。)

对应的从服务器返回的HTTP回复如下所示:

``` {.default}
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 6
Connection: close

Hello!
```

这个回复表示: “你的请求已经成功接收，这里是给你的带有6个字节明文的应答。同时，我将会在将此消息发送给你之后关闭连接，这个应答里的负载是'Hello!'。”注意，这里的 `Content-Length` 字段值是6，正好对应负载 `Hello!` 的长度，6个字节。

其它常用的负载字段是 `Content-Type`， 通常如果负载是HTML数据的话，该字段会被填充为 `text/html`。

## 客户端

客户端程序文件名为`webclient.py`，你可以在编写服务器端程序之前先编写客户端程序，因为客户端程序可以对着真实的现有web服务器上进行测试。在正式测试之前，不需要同时编写客户机和服务器。

该客户端程序的目标是可以通过命令行运行，运行方法如下所示:

``` {.sh}
$ python webclient.py example.com
```

得到输出应该如下所示:

``` {.default}
HTTP/1.1 200 OK
Age: 586480
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Thu, 22 Sep 2022 22:20:41 GMT
Etag: "3147526947+ident"
Expires: Thu, 29 Sep 2022 22:20:41 GMT
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Server: ECS (sec/96EE)
Vary: Accept-Encoding
X-Cache: HIT
Content-Length: 1256
Connection: close

<!doctype html>
<html>
<head>
    <title>Example Domain</title>
    ...
```

(为了方便展示，这里的输出被截断了，在你的测试中，应该会有网站的整个HTML内容。)

这里需要注意的是，输出的第一部分是包含来自服务器的所有字段的HTTP响应，然后有一个空行，空行后面的所有内容都是响应负载内容。同时: 在运行客户端程序时，你需要指定一个端口号来连接服务器端，当你没有指定时，会用端口号80作为默认值。所以，你同样可以使用不同的端口号连接跑在非80端口的网站服务。方法如下所示:

``` {.sh}
$ python webclient.py example.com 8088
```

这时程序会尝试连接8088端口上的服务端程序。

在客户端Python程序文件的最上端，需要导入socket包，这样你才能使用下面的这些函数。

``` {.py}
import socket
```

下面是客户端程序里主要使用的函数以及其作用:

* 使用 `socket.socket()` 创建一个新的套接字，不需要给它传递任何参数--默认参数对于此项目足够使用了。
  
* 使用 `s.connect()` 将新创建的套接和目的地连接起来，在这里，你可以不用显示的去处理DNS相关的步骤，因为`.connect()`函数已经帮你做好了这一步。此函数使用一个元组作为参数，分别表示服务器名和端口号。
  ``` {.py}
  ("example.com", 80)
  ```

* 接下来就是，构造并且发送该HTTP请求，你可以使用上面介绍过的那个简单的HTTP请求。**别忘了在消息头之后的空行， 也别忘了所有行都是使用`"\r\n"`结尾**。 我推荐使用 `s.sendall()` 方法来发生构造好的请求，你也可以使用 `.send()`，不过该函数可能只会发送出去一部分函数。（使用C语言的程序员可以在我的另一本书中找到`sendall()`的实现方法。）

* 使用`s.recv()`来接收网站服务器的响应，服务器通常会返回一些字节作为响应消息。如果服务器端是一个大型的网站服务器，通常客户端需要在循环中多次调用该函数来得到完整的信息。当服务器关闭连接并且没有更多的数据要读取时，它将返回一个零元素的字节数组，例如:
  ``` {.py}
  d = s.recv(4096)  # Receive up to 4096 bytes
  if len(d) == 0:
      # all done!
  ```

* 当一切结束时，调用 `s.close()` 来关闭该套接字。你可以使用下面的命令来测试你的客户端和一些网站的交互:
  ``` {.sh}
  $ python webclient.py example.com
  $ python webclient.py google.com
  $ python webclient.py oregonstate.edu
  ```

## 服务端

服务端程序文件被命名为`webserver.py`。

用户可以使用以下命令从命令行启动服务端程序, 如下所示， 服务器程序会被启动并且会在28333监听连接。

``` {.sh}
$ python webserver.py
```

同样，用户可以显示的指定服务器端程序监听的端口号，方法如下所示:

``` {.sh}
$ python webserver.py 12399
```
服务器端程序会一直运行着，以便于接收各种接进来的请求。（永远代表着只有当你按下ctrl+c的时候才会停止。）

我们这个项目中的服务器端程序，无论请求是什么，都只会简单的回复同一条消息，让它发回简单的服务器响应，如上所示。所以这不是一个全功能的网站服务器，不过它可以作为复杂程序的起点。

下面是该程序的一些Python技术细节:

* 像客户端程序一样，先向操作系统申请一个套接字。

* 当调用`socket()`函数之后，你需要添加看起来很疯狂的一行:

  ``` {.py}
  s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
  ```
  
  变量`s`是你从`socket()`得到的套接字描述符，这将防止在某些情况下`bind()` 上出现"Address already in use"错误，这个错误通常会让人感到困扰，通常发生在服务器崩溃之后。后面的章节中我们会介绍为什么会出现这个错误。

  如果你对添加这行代码感到厌倦，然后得到了这个错误，只需要等待几分钟，这样操作系统会断开的一些现有的连接。

* 调用`s.bind()`将套接字绑定在一个端口上，该函数需要携带一个参数，一个你想要绑定的地址和端口信息的元组。可以将地址置空表示绑定本地地址，比如，“绑
  定在任一本地地址的28333端口”可以传递如下参数:

  ``` {.py}
  ('', 28333)
  ```

* 调用`s.listen()`将套接字激活并开始监听。
  
* 调用`s.accept()`接收新的连接，注意，这个函数将会返回一个元组。元组的第一个元素是一个代表新连接的新套接字。（旧的套接字依然会保持监听状态直到用户在结束处理该次请求之后再次调用`s.accept()`。）
  ``` {.py}
  new_conn = s.accept()
  new_socket = new_conn[0]  # This is what we'll recv/send on
  ```

* 接收从客户端来的请求，类似于在客户端程序里面一样，需要在一个循环中调用`new_socket.recv()`，当服务器端接收到一个空行（例如，`"\r\n\r\n"`）表
  示服务器读取了足够的消息并且可以退出了。(在本项目中，我们不会处理负载，关于这个正确的思路是查看请求中的 `Content-Length`字段的数值，然后将报头加上对应的数值，这对于你可以作为一个附加题。)
  **注意**: 这次，你不能通过判断`recv()`是否返回一个空字符串来判断是否终止循环，空字符串只会发生在客户端已经关闭了连接，但是客户端端没有完全成功关闭并且依然在等待回复。所以正确的做法应该是一直调用`recv()`直到看到消息头最后的空行。

* 服务器端发送回复，以上面的描述，此项目中的服务器只会发送“一个简单的回复”。

* 使用`new_socket.close()`关闭用于接收的套接字。

* 继续使用`s.accept()`接收下一次请求。

现在，你可以在一个窗口中运行网站服务器程序而在另一个窗口中运行客户端，用来检查是否它们会互相连接！一旦服务器端程序可以和`webclient.py`通信，下面尝试使用网页浏览器程序来打开它！ 首先，在一个未被使用的端口上运行改程序（请选择一个随机的大一点的数字）: 
``` {.sh}
$ python webserver.py 20123
```

在浏览器中打开[`http://localhost:20123/`](http://localhost:20123/) 查看这个网页（`localhost` 是“该计算机名”。），如果你看到了相应的内容，那么恭喜你，服务器端程序已经成功了！  

尝试去打印出`.accept()`函数收到的内容，看看输出是什么？

你有没有注意到，如果你使用网络浏览器连接到你的服务器，浏览器实际上会建立两个连接?如有兴趣可以深入研究一下，看看你是否能找出原因!

## 提示和帮助

### 地址已经被使用

如果你的服务器程序崩溃了，而你试图重新启动它，这时你会得到一个“地址已经在使用”的错误，这说明着系统还没有完成端口销毁工作(在这种情况下，“地址”在这里指的是端口。)。如想消除这个错误，要么使用另一个端口启动服务器程序，要么等待一两分钟，这时会出现超时，操作系统会进行清理。

### 接收到部分数据

即使你告诉`recv()`函数你想要接收到4096字节的数据，该次调用也无法保证你能全部收齐指定多数据。有可能服务器发送少了，也有可能是在传输中，数据发生了分割，只有部分数据被接收到。

调用`recv()`函数却不能得到完整的数据，使得在处理HTTP请求或者回复中显得很棘手。更糟糕的是，数据在传输中可能会在标题末尾的空行分隔符的中间被分割!

不要对于一次`recv()`调用就能接收到所有数据抱有幻想。永远在一个循环中调用该函数，将收到的数据不断附加到一个缓冲中，直到你收到了你需要的数据。

当你尝试对一个已经关闭的连接调用`recv()`函数时，它会返回一个空字符串（Python中）或者`0`（C语言中），这就是如何判断连接已关闭的方法。

### HTTP 状态码 301，302

当你的客户端收到服务器端发来的`301`或者`302`的状态码时，大概率还会带有`Moved Permanently`或者`Moved Temporarily`的消息，这说明你正在请求的URL中的服务器资源已经被移动到另一个URL。

如果你查看一下的消息头，你会发现一个`Location:`字段:

例如，当你运行`webclient.py google.com`时，你会收到如下消息:

``` {.default}
HTTP/1.1 301 Moved Permanently
Location: http://www.google.com/
Content-Type: text/html; charset=UTF-8
Date: Wed, 28 Sep 2022 20:41:09 GMT
Expires: Fri, 28 Oct 2022 20:41:09 GMT
Cache-Control: public, max-age=2592000
Server: gws
Content-Length: 219
X-XSS-Protection: 0
X-Frame-Options: SAMEORIGIN
Connection: close

<HTML><HEAD><meta http-equiv="content-type" content="text/html;charset=utf-8">
<TITLE>301 Moved</TITLE></HEAD><BODY>
<H1>301 Moved</H1>
The document has moved
<A HREF="http://www.google.com/">here</A>.
</BODY></HTML>
Connection closed by foreign host.
```

注意，消息系的第一行告诉我们所请求的资源已经被挪走，第二行的`Location:`字段告诉我们该资源被移动到了哪里。

当一个网页浏览器看到`301`消息码时，它会自动切换到另外的URL，用户无需担心处理该过程。

你可以试试在浏览器中输入`google.com`然后你会发现过一会儿之后浏览器里的地址自动切换成了`www.google.com`。

### HTTP状态码400，501（以及任何500状态码）

如果客户端从服务器获得`400`或任何`500`的响应代码,很有可能你发出了一个错误的请求，简而言之，该请求所携带的数据在某种程度上是错误的。确保消息头的每个字段都以`\r\n`结尾，并且消息头以空行结束(即:`\r\n\r\n`是消息头的最后4个字节)。

### HTTP 状态码404，资源未找到！

请确保在你的请求中含有`Host:`字段并且正确的设置成了和你传入命令行中一样的内容，如果设置错误，将会得到404错误。

## 扩展练习

下面是一些可以让你加强理解的练习，请务必尝试一把！

* 修改服务器端代码，打印出连接上来的客户端IP地址和端口号。提示:可以查询下Python中`accept()` 函数的返回值。

* 修改客户端程序，使其可以发送负载数据，你需要根据负载内容正确设置`Content-Type`和`Content-Length`。
  
* 修改服务器代码，从请求中解析和打印“请求方法”，大部分会是`GET`，不过也有可能会出现`POST`或者`DELETE`。

* 修改服务器端代码，解析并打印客户端发送的负载信息。
