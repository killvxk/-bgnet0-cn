# 附录：位运算{#appendix-bitwise}

在本节中，我们将会复习 _位运算操作_。

编程语言中的位运算符是指对数字的位进行运算的操作。这些运算符将数字当做是一个个用二进制，即使它不是。但其实，它们可以在Python代码中处理任何基数的数字，但对我们人类来说，二进制是最直观的。

> 高级技巧: 记住，不同的数字进制，比如十六进制，二进制和十进制，只是表示一个值的不同方式。
> 这就像是在不同的语言中同一个数字有不同的表示方式一样。
>
> 当一个值存储在变量中时，最好的做法是把它看作是纯数字形式的存在——根本没有基数。只有当你把
> 它写下来(用代码或打印出来)的时候，基数才会起作用。
>
> 比如，Python 默认会以基数10为基础打印每一个数字。它有各种方法来覆盖它并以另一种基数输出。
> Protip: remember that different number bases like hex, binary, and
> decimal are just different ways of writing a value down. Kind of like
> different languages for representing the same numeric value.

我们将要学习:
* Python中不同进制
* 在Python中以不同的基打印结果
* 位与运算
* 位或运算
* 位非运算
* 移位位运算
* 将指定数字位置`1`

## Python中不同进制

`110101`值是什么？

你的大脑可能会认为我在问:“这个二进制数用十进制表示是多少?”但你错了!我并没有指定这个数字的基数，所以你不知道它是二进制、十进制还是十六进制!

现在我声明一下，这个值是十进制，所以是110,1001。Python和大多数其他语言都假定代码中的数字是十进制的，除非用户自行指定。如果你想要一个不同的基数，你必须在数字前加上前缀来表示使用的是什么基数。

在Python中支持的基数有:
<!-- 图是： Python中的不同基数 -->
|基数|基数名称|前缀|
|-|-|-|
|2|二进制|`0b`|
|8|八进制|`0o`|
|10|十进制|None|
|16|十六进制|`0x`|

下面，让我们来书写一些不同基数的数字:

``` {.default}
  110101 decimal!
0b110101 binary!
0x110101 hex!
```

让我们看一下十进制数 `3490`。我可以把它转换成十六进制，得到`0xda2`。请记住，下面的这两个数字是相等的:

``` {.py}
>>> 3490 == 0xda2
True
```

这就是计算机中不同“语言”表示同一个数字。

## 输出和转换

请记住，变量中不存在“以十六进制存储”或“以十进制存储”的值的概念。一个变量只保存一个数值，我们不应该认为它有基数。只有在编写代码或输出时，它才会获得一个基数值，而代码编写者需要指定该基数值。(尽管Python在所有情况下都默认使用十进制。)

你可以使用`hex()`函数将值转换为十六进制字符串。所有“转换”的值最终都是字符串，也不会转换成其他类型了。

``` {.py}
>>> print(hex(3490))
0xda2
```

同样，你可以使用`bin()` 函数将一个数值转换为二进制字符串。

``` {.py}
>>> print(bin(3490))
0b110110100010
```

当然，你也可以使用python中的f-strings来完成这个工作。

``` {.py}
>>> print(f"3490 is {3490:x} in hex and {3490:b} in binary")
3490 is da2 in hex and 110110100010 in binary
```

f-string有一个很好的特性，它可以被填充到一个带有零的字段宽度。假设你想要一个8位十六进制数字表示，你可以这样做:

``` {.py}
>>> print(f"3490 is {3490:08x} in hex")
3490 is 00000da2 in hex
```

## 位与运算

位与运算，使用AND操作将两个数字连接在一起。如果两个输入位都为`1` ，则与运算的结果为`1` 。否则就是`0`。

<!-- 图示: 位与运算真值表 -->
|A|B|A AND B|
|:-:|:-:|:-:|
|0|0|0|
|0|1|0|
|1|0|0|
|1|1|1|

我们通过一个例子来看下具体的两个数的位与运算。和许多其他语言中使用与符号操作符(`&`)一样，与运算在python中依然以这个符号表示。

``` {.default}
  0     0     1     1
& 0   & 1   & 0   & 1
---   ---   ---   ---
  0     0     0     1
```

只有当两个输入位都为`1`时，结果才为`1`。

下面的这个大数通过位与运算计算每一位的结果，可以查看下面数字中的每一列计算的结果。(为了完整显示，十进制结果显示在右侧，但这是从二进制表示派生的。因为看两个十进制数并确定它们的位与运算结果并不直观。)

``` {.default}
  0100011111000101010      146986
& 1001111001001111000    & 324216
---------------------    --------
  0000011001000101000       12840
```

可以仔细查看只有上面的运算中，只有两个列中的两个位都是 `1` 时，输出位的结果才是 `1` 。

## 位或运算

位或运算，使用OR操作将两个数字连接在一起。如果两个输入位中有一位或者两位都是`1` ，则与运算的结果为`1` 。否则就是`0`。

<!-- 图示: 位或运算真值表 -->
|A|B|A OR B|
|:-:|:-:|:-:|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|1|

我们通过一个例子来看下具体的两个数的位或运算。和许多其他语言中使用与符号操作符(`|`)一样，或运算在python中依然以这个符号表示。

``` {.default}
  0     0     1     1
| 0   | 1   | 0   | 1
---   ---   ---   ---
  0     1     1     1
```

可以看到，结果为`1`的位，输入位至少有一个是`1`。下面的这个大数通过位或运算计算每一位的结果，可以查看下面数字中的每一列计算的结果。(为了完整显示，十进制结果显示在右侧，但这是从二进制表示派生的。因为看两个十进制数并确定它们的位或运算结果并不直观。)

``` {.default}
  0100011111000101010      146986
| 1001111001001111000    | 324216
---------------------    --------
  1101111111001111010      458362
```

可以仔细查看只有上面的运算中，当至少一个列是 `1` 时，输出位的结果才是 `1` 。

## 位非运算

位否运算会把所有的 `1`  _翻转_ 成 `0`和所有的`0` _翻转_ 成`1`。 这是一个一元操作符--它只在一个数字上起作用。

<!-- 图示: 位非运算真值表 -->
|A|B|A OR B|
|:-:|:-:|:-:|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|1|

我们通过一个例子来看下具体的一个数的位非运算。和许多其他语言中使用与符号操作符(`~`)一样，非运算在python中依然以这个符号表示。

``` {.default}
~ 0   ~ 1
---   ---
  1     0
```

你可以看到，运算的结果仅仅是简单的反转了位的值。

下面的这个大数通过位非运算计算每一位的结果，可以查看下面数字中的每一列计算的结果。(为了完整显示，十进制结果显示在右侧，但这是从二进制表示派生的。因为看两个十进制数并确定它们的位非运算结果并不直观。)


``` {.default}
~ 0100011111000101010    ~ 146986
---------------------    --------
  1011100000111010101      377301
```

可以看到，输出中的每一位`1`都是`0`翻转得到的。 

Python提示:由于Python支持任意精度算术，直接进行非运算经常会得到负数。如果你需要保证它是正的，你需要使用位与运算，将数字最终所需位长度的全`1`的数进行与运算。例如，要获得' `37`反转的字节，你可以执行以下任何操作:

``` {.py}
(~37) & 255
(~37) & 0xff
(~37) & 0b11111111
```

(因为，当然，这些都是不同的基数表示下相同的数!)

## 移位运算

这是一个有趣的运算，利用此运算规则，你可以将一个数来回移动一定的位数。下面是如何将一个数的所有位左移2位的例子:

``` {.default}
000111000111  left shifted by 2 is:
011100011100
```

或者我们也可以向右移:

``` {.default}
000111000111  right shifted by 2 is:
000001110001  
```

左边或者右边新产生的位置为0，而所有被移出的位会永远的被消除。

> 在这里，我对很多语言如何右移负数描述的不够准确。如果你将一个负数右移，新出现的位根据
> 语言的不同，可能是`1` 而不是`0`。Python里面的整数运算是任意精度的，所以实际上在
> Python中，任何负数的左边都有无限个`1` 位，这让可能会让你有时候对结果感到奇怪。
>
> 所以，在目前了解原理的阶段，只考虑正数。

`<<`在大多数语言中是左移，而 `>>`在大多数语言中表示右移（Ruby除外！）。让我们来看一个具体的例子:

``` {.py}
>>> v = 0b00000101
>>> print(f"{v << 2:08b}")
00010100
```

这里有一个二进制表示的数，我们用`v << 2`将该数左移了2个字节。你可以看到`101`已经向左移动了2位!

## 设置任意长度`1`位

如果我们想要得到一个连续位数为`1`的数，这是我们可以做的一个小技巧。举例来说，如果我们想要一个12位都为1的数，也就是:

``` {.py}
0b111111111111
```

我应该怎么做？ 我们可以用一些技巧，在这里让我们从技巧1开始。如果您想将第n位设置为`1`(其中最右边的位是位0)，则可以将2取该次幂，这样你就能得到它。

让我们将第5位设置为1，我们可以首先计算`2**5`，得到结果`32`，而`32`用二进制表示就是`100000`，我们得到了我们想要的。

另外一种方法是将`1`左移5位，也就是`1 << 5`得到 二进制`100000`，也就是十进制的`32`。也可以工作。

但是怎么从这里得到我们需要的连续的`1`呢?

看看这个，32减1等于多少?31. 这不是一个脑筋急转弯问题。让我们看看它们的二进制:

``` {.default}
32   100000
31   011111
```

嘿!这里有一连串的`1`!不仅如此，它还是5个连续的`1`，就像我们想要的那样!(这类似于十进制中的减法。10000 - 1等于9999。在二进制中，我们得到的结果都是`1`，而不是`9`。)

``` {.py}
run_of_ones = (1 << count) - 1
```

下面是如何得到连续12个`1`:

``` {.py}
>>> bin((1 << 12) - 1)
'0b111111111111'
```

如果你喜欢这些 _琐碎位运算的技巧_，你可能会喜欢这本书[Hacker’s Delight](https://en.wikipedia.org/wiki/Hacker%27s Delight)。第2章涵盖了许多这些技术，这些技术以前都是免费发布的，你可能可以找到一个PDF文件。

## 思考题

* `2342 & 2332`结果是什么？
  
* `0b110101 | 112`结果是什么？

* `~0b101010010101`用二进制表示是什么？（在Python中，会得到一个负数，不过你的可以将其和`0b111111111111`进行与运算转化成为一个正值。别忘了Python在打印输出时会自动消除前置0！）
  
* `16 << 1` 结果是什么？
  
* `64 << 1` 结果是什么？
  
* `4200 << 1` 结果是什么？有找到什么规律么？
  
* `16 >> 2` 结果是什么？
  
* `0b11100111 << 3` 结果是什么？

* `(1 << 8) - 1`结果是什么？

* `0x01020304 & ((1 << 16) - 1)` 结果是什么？


<!--
答案:

2342 & 2332
2308	0x904	0b100100000100

0b110101 | 112
117	0x75	0b1110101

(~0b101010010101)&0b111111111111
1386	0x56a	0b10101101010

16 << 1
32

64 << 1
128

4200 << 1
8400   Doubles

16 >> 2
4

0b11100111 << 3
1848	0x738	0b11100111000

 ~ %  (1 << 8) - 1
255	0xff	0b11111111

0x01020304 & ((1 << 16) - 1)
772	0x304	0b1100000100
-->

